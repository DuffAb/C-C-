###### 1. 链表
- 基本特征：内存中不连续的节点序列，节点之间通过next指针彼此相连；每个节点的next指针都指向下一个节点，最后一个节点的next指针为NULL。
- 基本操作：插入、删除、遍历。
- 实现要点：
 - 追加：将新分配节点的地址赋给原链表尾端节点的next指针。
 - 插入：将前节点中存储的后节点地址赋给新节点的next指针，将新节点的地址赋给前节点的next指针。
 - 删除：将前节点的next指针赋值为待删除节点的next指针。对于单向链表而言，寻找前节点会有一定开销。
 - 遍历：沿着next指针依次访问链表中的各个节点。
 - 伪随机访问：遍历+计数。

范例：
![](https://github.com/DuffAb/funny_shit/blob/master/DataStructure/Sample/LIST/images/double_list.png)

[双向线性链表](https://github.com/DuffAb/funny_shit/tree/master/DataStructure/Sample/STACK/ImplementByList) - ls.h、ls.c、ls_test.c

[小孩出列(约瑟夫环)](https://github.com/DuffAb/funny_shit/tree/master/DataStructure/Sample/STACK/ImplementByList) - joseph.c

练习：lsex.c
***
###### 2. 二叉树
1. 基本特征
 - A. 表达树形结构的最简模型，每个节点最多有两个子节点。
 - B. 单根，每个子节点有且仅有一个父节点，整棵树只有一个根节点。
 - C. 具有递归结构的特征，用递归的方法处理，可以简化算法。
2. 基本操作：生成、遍历。
3. 深度优先遍历二叉树
 - a) D：访问根结点，L：遍历根结点的左子树，R：遍历根结点的右子树
 - b) 前序遍历：(D-L-R) 处理节点自己的数据->处理左节点->处理右节点。
 - c) 中序遍历：(L-D-R) 处理左节点->处理节点自己的数据->处理右节点。
 - d) 后序遍历：(L-R-D) 处理左节点->处理右节点->处理节点自己的数据。
4. 广度优先遍历二叉树
 - A. 广度优先遍历的非递归的通用做法是采用队列。
 - B. 广度优先遍历二叉树(层序遍历)是用队列来实现的，从二叉树的第一层（根结点）开始，自上至下逐层遍历；在同一层中,按照从左到右的顺序对结点逐一访问。按照从根结点至叶结点、从左子树至右子树的次序访问二叉树的结点。
 - C. 算法：
    1. 初始化一个队列，并把根结点入列队；
    2. 当队列为非空时，循环执行步骤3到步骤5，否则执行6；
    3. 出队列取得一个结点，访问该结点；
    4. 若该结点的左子树为非空，则将该结点的左子树入队列；
    5. 若该结点的右子树为非空，则将该结点的右子树入队列；
    6. 结束。


范例：

有序二叉树(二叉搜索树) - bt.h、bt.c、bt_test.c

练习：trex.c
